#!/usr/bin/ruby

require 'gtk3'
require 'json'

class DisplayerGUI
  def initialize timeout: 10, conf_path: '/etc/displayer/conf'
    @conf_path = conf_path
    @timeout = timeout
    @builder = Gtk::Builder.new
    @builder.add_from_file '/opt/displayer/displayer-gui.glade'
    # read config file
    read_conf
    # attach signals handlers
    @builder.connect_signals do |handler|
      begin
        method(handler)
      rescue
        puts "#{handler} not yet implemented!"
        method('not_yet_implemented')
      end
    end
    # make elements available as instance variables
    [ :btn_capitalize, :window_config, :window_main, :label_check_wifi,
      :label_check_internet, :label_check_host, :btn_start
    ].each do |element_name|
      instance_variable_set "@#{element_name}", @builder.get_object(element_name)
    end
    # iterate
    startable_since = false
    first_run = Time.now
    last_run = Time.now - 2
    while true
      if (Time.now - last_run) > 1
        check_wifi = system "nmcli c show --active | grep -q wifi"
        @label_check_wifi.text = "#{check_wifi}"
        check_internet = system "ping -w 2 -c 1 8.8.8.8 &> /dev/null"
        @label_check_internet.text = "#{check_internet}"
        @check_host = system "ping -w 2 -c 1 #{@conf["host"]} &> /dev/null"
        @label_check_host.text = "#{@check_host}"
        last_run = Time.now
        return if autostart
        @window_main.show()
      end
      Gtk.main_iteration_do false # nonblockingmain_quit
      sleep 0.01
    end
  end

  def autostart
    @startable_since = false unless @check_host
    @startable_since = Time.now if @check_host and not @startable_since
    unless @user_interacted
      if @startable_since
        if  Time.now - @startable_since < @timeout
          @btn_start.label = "starts in #{(@timeout - (Time.now - @startable_since)).round} seconds"
        else
          return true
        end
      else
        @btn_start.label = "no connection"
      end
    else
      if @check_host
        @btn_start.label = "start"
      else
        @btn_start.label = "no connection"
      end
    end
    return false
  end

  def read_conf
    conf_from_file = JSON.parse File.read @conf_path
    p conf_from_file
    @conf = {}
    [ :wifi_ssid, :wifi_pass, :checkbox_wpa2e, :wifi_user, :host,
      :path, :user, :pass
    ].each do |name|
      @conf[name.to_s] = conf_from_file[name.to_s] || ""
      element = @builder.get_object("conf_#{name}")
      element.text = @conf[name.to_s] if element.class == Gtk::Entry
      element.active = @conf[name.to_s] if element.class == Gtk::CheckButton
    end
    @conf_orig = @conf.dup
  end

  def config_changed object=nil
    # deprecated
  end

  def write_conf
    @conf.keys.each do |name|
      element = @builder.get_object("conf_#{name}")
      if element.class == Gtk::Entry
        @conf[name] = element.text
      elsif element.class == Gtk::CheckButton
        @conf[name] = element.active?
      end
    end
    File.write "/etc/displayer/conf", @conf.to_json
  end

  def btn_start
    exit if @check_host
  end

  def btn_configure object=nil
    @user_interacted = true
    @builder.get_object('window_config').run
  end

  def btn_keyboard object=nil
    focus = @window_config.focus
    if focus and focus.class == Gtk::Entry
      char = object.label
      pos = focus.position
      char.upcase! if @btn_capitalize.active?
      focus.text = focus.text.insert(pos, char)
      focus.position = pos + char.length
    end
  end

  def btn_capitalize object=nil
    puts object.active?
  end

  def btn_delete object=nil
    pos = @window_config.focus.position
    text = @window_config.focus.text
    text.slice! pos-1
    @window_config.focus.text = text
    @window_config.focus.position = pos-1
  end

  def btn_ok object=nil
    @conf_orig = @conf.dup
    write_conf
    @window_config.hide
  end

  def on_main_window_destroy(object)
    Gtk.main_quit()
  end
end

DisplayerGUI.new
